"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6912],{96912:function(e,i,n){n.d(i,{OpenloginAdapter:function(){return OpenloginAdapter},getOpenloginDefaultOptions:function(){return getOpenloginDefaultOptions}});var t=n(81838),o=n(18291),s=n(21076),r=n(7649),a=n(93745),c=n.n(a);let getOpenloginDefaultOptions=(e,i)=>({adapterSettings:{network:t.dr.MAINNET,clientId:"",uxMode:t.$e.POPUP},chainConfig:e?(0,o.h2)(e,i):null,loginSettings:{}});function ownKeys(e,i){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);i&&(t=t.filter(function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable})),n.push.apply(n,t)}return n}function _objectSpread(e){for(var i=1;i<arguments.length;i++){var n=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(n),!0).forEach(function(i){(0,s.Z)(e,i,n[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ownKeys(Object(n)).forEach(function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))})}return e}let OpenloginAdapter=class OpenloginAdapter extends o.J5{constructor(e){var i,n,r,a;super(),(0,s.Z)(this,"name",o.rW.OPENLOGIN),(0,s.Z)(this,"adapterNamespace",o.yk.MULTICHAIN),(0,s.Z)(this,"type",o.hN.IN_APP),(0,s.Z)(this,"openloginInstance",null),(0,s.Z)(this,"status",o.MP.NOT_READY),(0,s.Z)(this,"currentChainNamespace",o.EN.EIP155),(0,s.Z)(this,"openloginOptions",void 0),(0,s.Z)(this,"loginSettings",{}),(0,s.Z)(this,"privKeyProvider",null),o.cM.debug("const openlogin adapter",e);let c=getOpenloginDefaultOptions(null===(i=e.chainConfig)||void 0===i?void 0:i.chainNamespace,null===(n=e.chainConfig)||void 0===n?void 0:n.chainId);if(this.openloginOptions=_objectSpread(_objectSpread({clientId:"",network:t.dr.MAINNET},c.adapterSettings),e.adapterSettings||{}),this.loginSettings=_objectSpread(_objectSpread({},c.loginSettings),e.loginSettings),this.sessionTime=this.loginSettings.sessionTime||86400,null!==(r=e.chainConfig)&&void 0!==r&&r.chainNamespace){this.currentChainNamespace=null===(a=e.chainConfig)||void 0===a?void 0:a.chainNamespace;let i=c.chainConfig?c.chainConfig:{};if(this.chainConfig=_objectSpread(_objectSpread({},i),null==e?void 0:e.chainConfig),o.cM.debug("const openlogin chainConfig",this.chainConfig),!this.chainConfig.rpcTarget&&e.chainConfig.chainNamespace!==o.EN.OTHER)throw o.Ty.invalidParams("rpcTarget is required in chainConfig")}}get chainConfigProxy(){return this.chainConfig?_objectSpread({},this.chainConfig):null}get provider(){var e;return(null===(e=this.privKeyProvider)||void 0===e?void 0:e.provider)||null}set provider(e){throw Error("Not implemented")}async init(e){var i;if(super.checkInitializationRequirements(),!(null!==(i=this.openloginOptions)&&void 0!==i&&i.clientId))throw o.Ty.invalidParams("clientId is required before openlogin's initialization");if(!this.chainConfig)throw o.Ty.invalidParams("chainConfig is required before initialization");let n=!1;if(this.openloginOptions.uxMode===t.$e.REDIRECT){let e=(0,t.Gv)();Object.keys(e).length>0&&e._pid&&(n=!0)}this.openloginOptions=_objectSpread(_objectSpread({},this.openloginOptions),{},{replaceUrlOnRedirect:n}),this.openloginInstance=new t.ZP(this.openloginOptions),o.cM.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=o.MP.READY,this.emit(o.n2.READY,o.rW.OPENLOGIN);try{o.cM.debug("initializing openlogin adapter"),this.openloginInstance.privKey&&(e.autoConnect||n)&&await this.connect()}catch(e){o.cM.error("Failed to connect with cached openlogin provider",e),this.emit("ERRORED",e)}}async connect(e){super.checkConnectionRequirements(),this.status=o.MP.CONNECTING,this.emit(o.n2.CONNECTING,_objectSpread(_objectSpread({},e),{},{adapter:o.rW.OPENLOGIN}));try{return await this.connectWithProvider(e),this.provider}catch(e){if(o.cM.error("Failed to connect with openlogin provider",e),this.status=o.MP.READY,this.emit(o.n2.ERRORED,e),null!=e&&e.message.includes("user closed popup"))throw o.RM.popupClosed();throw o.RM.connectionError("Failed to login with openlogin")}}async disconnect(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==o.MP.CONNECTED)throw o.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw o.Ty.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),e.cleanup?(this.status=o.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=o.MP.READY,this.emit(o.n2.DISCONNECTED)}async authenticateUser(){if(this.status!==o.MP.CONNECTED)throw o.RM.notConnectedError("Not connected with wallet, Please login/connect first");let e=await this.getUserInfo();return{idToken:e.idToken}}async getUserInfo(){if(this.status!==o.MP.CONNECTED)throw o.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw o.Ty.notReady("openloginInstance is not ready");let e=await this.openloginInstance.getUserInfo();return e}setAdapterSettings(e){if(this.status===o.MP.READY)return;let i=getOpenloginDefaultOptions();this.openloginOptions=_objectSpread(_objectSpread(_objectSpread({},i.adapterSettings),this.openloginOptions||{}),e),e.sessionTime&&(this.loginSettings=_objectSpread(_objectSpread({},this.loginSettings),{},{sessionTime:e.sessionTime}))}setChainConfig(e){super.setChainConfig(e),this.currentChainNamespace=e.chainNamespace}async connectWithProvider(e){if(!this.chainConfig)throw o.Ty.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw o.Ty.notReady("openloginInstance is not ready");if(this.currentChainNamespace===o.EN.SOLANA){let{SolanaPrivateKeyProvider:e}=await Promise.all([n.e(3814),n.e(6318),n.e(1103),n.e(7918)]).then(n.bind(n,45230));this.privKeyProvider=new e({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===o.EN.EIP155){let{EthereumPrivateKeyProvider:e}=await Promise.all([n.e(5917),n.e(3258),n.e(790),n.e(8890)]).then(n.bind(n,50790));this.privKeyProvider=new e({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===o.EN.OTHER)this.privKeyProvider=new r.FL;else throw Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));if(!this.openloginInstance.privKey&&e){var i;this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===o.EN.SOLANA?t.x7.ED25519:t.x7.SECP256K1),await this.openloginInstance.login(c()(this.loginSettings,{loginProvider:e.loginProvider},{extraLoginOptions:_objectSpread(_objectSpread({},e.extraLoginOptions||{}),{},{login_hint:e.login_hint||(null===(i=e.extraLoginOptions)||void 0===i?void 0:i.login_hint)})}))}let s=this.openloginInstance.privKey;if(s){if(this.currentChainNamespace===o.EN.SOLANA){let{getED25519Key:e}=await Promise.all([n.e(6318),n.e(7516)]).then(n.bind(n,74408));s=e(s).sk.toString("hex")}await this.privKeyProvider.setupProvider(s),this.status=o.MP.CONNECTED,this.emit(o.n2.CONNECTED,{adapter:o.rW.OPENLOGIN,reconnected:!e})}}}}}]);